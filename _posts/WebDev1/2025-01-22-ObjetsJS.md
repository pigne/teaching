---
layout: post
title: CrÃ©ation et Manipulation dâ€™Objets en JavaScript
categories:
- WebDev1
- lecture
author: Yoann PignÃ©
published: true
update: 2025-02-01
---



## Points clÃ©s :

- **Les objets** en JavaScript sont des conteneurs mutables pour des propriÃ©tÃ©s. Une propriÃ©tÃ© est une paire clÃ©-valeur, oÃ¹ la clÃ© est une chaÃ®ne de caractÃ¨res (ou un symbole), et la valeur peut Ãªtre n'importe quelle valeur JavaScript valide.
- **Les objets littÃ©raux** sont la maniÃ¨re la plus simple de crÃ©er un objet. Par exemple :

  ```js
  const w = {
      'Â°C': 27,
      humidity: '80%',
      place: 'Le Havre'
  };
  ```

- Vous pouvez **accÃ©der aux propriÃ©tÃ©s d'un objet** en utilisant soit la notation pointÃ©e, soit la notation entre crochets :

  ```js
  w['Â°C']; // 27
  w.humidity; // '80%'
  ```

  Lorsqu'une propriÃ©tÃ© n'existe pas, elle retourne `undefined` :

  ```js
  w.pressure; // undefined
  ```

- Vous pouvez **modifier les propriÃ©tÃ©s** ainsi :

  ```js
  w.pressure = 1030;
  w.place = 'Nice';
  ```

- **Les objets sont passÃ©s par rÃ©fÃ©rence**, donc les modifications effectuÃ©es sur un objet se reflÃ©teront dans toutes les variables qui y font rÃ©fÃ©rence :

  ```js
  const w2 = w;
  w['Â°C'] = 34;
  console.log(w2['Â°C']); // 34
  ```

## La chaÃ®ne de prototypes :

- Chaque objet en JavaScript a un *prototype* implicite. Par dÃ©faut, tous les objets hÃ©ritent de `Object.prototype`.
- Les **prototypes** permettent aux objets d'hÃ©riter de propriÃ©tÃ©s et de mÃ©thodes d'autres objets. 
- La recherche de propriÃ©tÃ©s et de mÃ©thodes se fait en remontant la chaÃ®ne de prototypes jusqu'Ã  `Object.prototype`.

```
object
â”œâ”€â”€ properties
â”‚   â””â”€â”€ ...
â””â”€â”€ *prototype*
    â”œâ”€â”€ properties
    â”‚   â””â”€â”€ ...
    â””â”€â”€ *prototype*
        â””â”€â”€ ...
```

Exemple : 

  ```js
  const o = {
      'a': 0,
      'b': false
  };
  
  Object.prototype.ok = function() {
      return 'C\'est OK !';
  };
  
  Object.prototype.not_ok = 'Pas OK.';
  
  console.log(o.ok()); // 'C'est OK !'
  console.log(o.not_ok); // 'Pas OK.'
  ```

- Dans cet exemple, l'objet `o` n'a pas la mÃ©thode `ok` ni la propriÃ©tÃ© `not_ok`, mais il peut y accÃ©der car elles sont hÃ©ritÃ©es de `Object.prototype`Â :

  ```
  object : `o`
  â”œâ”€â”€ properties
  â”‚   â”œâ”€â”€ 'a': 0
  â”‚   â””â”€â”€ 'b': false
  â””â”€â”€ *prototype*
      â”œâ”€â”€ properties
      â”‚   â”œâ”€â”€ ok: [Function]
      â”‚   â””â”€â”€ not_ok: 'Pas OK.'
      â””â”€â”€ *prototype*
          â””â”€â”€ undefined
  ```

Cela montre comment les prototypes permettent aux objets d'accÃ©der Ã  des propriÃ©tÃ©s et mÃ©thodes qui ne sont pas directement dÃ©finies sur eux.






## Approches pour crÃ©er un objet en JavaScript

### Objet littÃ©ral (`{}`)

ğŸ“Œ Lâ€™approche la plus simple et intuitive, mais **pas idÃ©ale** pour des objets partageant des mÃ©thodes.

```js
const book = {
  title: "1984",
  author: "George Orwell",
  read() {
    console.log(`Vous lisez "${this.title}" de ${this.author}.`);
  }
};

book.read(); // Vous lisez "1984" de George Orwell.
```

âœ… Simple et lisible.  
âŒ Pas de partage efficace des mÃ©thodes : chaque instance **duplique** les fonctions.

---

### `Object.create()`, prototypes et champs cachÃ©s


La fonctionnalitÃ© la plus importante de `Object.create` est de permettre de dÃ©finir des objets sÃ©curisÃ©s. Les valeurs peuvent Ãªtre en **lecture seule** ou protÃ©gÃ©es par des **accesseurs**â€¦ Les attributs ne peuvent pas vraiment Ãªtre **privÃ©s**, mais ils peuvent Ãªtre cachÃ©s.

#### Exemple :

```js
var obj = Object.create(null); // Objet sans lien de prototype

var obj2 = Object.create(Object.prototype); // Ã©quivalent Ã  "var obj2 = {};"

var positivePoint = Object.create(Object.prototype, {
  x: {
    get: function() { return this._x || 0; },
    set: function(value) {
      if (value < 0) {
        console.log("Erreur ! Ce point doit avoir des valeurs positives", this.y);
      } else {
        this._x = value;
      }
    },
  },
  y: {
    get: function() { return this._y || 0; },
    set: function(value) {
      if (value < 0) {
        console.log("Erreur ! Ce point doit avoir des valeurs positives");
      } else {
        this._y = value;
      }
    },
  },
  toString: {
    value: function() {
      return '(' + this.x + ', ' + this.y + ')';
    },
  }
});
```

#### Utilisation :

```js
positivePoint.x = 10;  // DÃ©finit x Ã  10
positivePoint.y = -5;  // Affiche l'erreur, car y ne peut pas Ãªtre nÃ©gatif
positivePoint.y = 5;   // DÃ©finit y Ã  5

console.log(positivePoint.toString()); // (10, 5)
```

Cela montre comment `Object.create` permet de crÃ©er des objets sÃ©curisÃ©s en contrÃ´lant l'accÃ¨s Ã  leurs propriÃ©tÃ©s et en cachant des donnÃ©es internes.




âœ… CrÃ©er des objets sÃ©curisÃ©s en contrÃ´lant l'accÃ¨s Ã  leurs propriÃ©tÃ©s et en cachant des donnÃ©es internes.  
âœ… Bonne maÃ®trise de lâ€™hÃ©ritage **sans utiliser `class`**.  
âŒ Moins intuitif que `class` et peu utilisÃ© en pratique.

---

### Fonction Constructeur (`new` + Prototype)

ğŸ“Œ Une mÃ©thode classique pour crÃ©er plusieurs objets partageant des mÃ©thodes.

#### ğŸ”¹ Exemple : Une gestion dâ€™inventaire
```js
function Product(name, price) {
  this.name = name;
  this.price = price;
}

// Ajout d'une mÃ©thode partagÃ©e via le prototype
Product.prototype.displayInfo = function () {
  console.log(`${this.name} coÃ»te ${this.price}â‚¬`);
};

const laptop = new Product("MacBook", 2500);
const phone = new Product("iPhone", 1200);

laptop.displayInfo(); // MacBook coÃ»te 2500â‚¬
phone.displayInfo();  // iPhone coÃ»te 1200â‚¬

console.log(laptop.__proto__ === Product.prototype); // true
```

âœ… Plus performant que lâ€™objet littÃ©ral grÃ¢ce au **partage de mÃ©thodes via `prototype`**.  
âŒ Syntaxe plus lourde et **remplacÃ©e par `class`** en ES6.

---

### Class `class` en ES6 (Design Pattern `Class` + Champs PrivÃ©s)

ğŸ“Œ Le `class` en ES6 simplifie lâ€™approche objet avec une syntaxe plus intuitive.

Exemple : Gestion dâ€™utilisateurs avec champs privÃ©s (`#`)

```js
class User {
  #password; // Champ privÃ©

  constructor(username, password) {
    this.username = username;
    this.#password = password;
  }

  checkPassword(input) {
    return this.#password === input;
  }

  get usernameInfo() {
    return `Utilisateur: ${this.username}`;
  }
}

const user = new User("Alice", "supersecret");
console.log(user.username); // Alice
console.log(user.checkPassword("supersecret")); // true
console.log(user.#password); // Erreur ! (Champ privÃ©)
```

âœ… Plus **lisible** et proche dâ€™autres langages orientÃ©s objet.  
âœ… PossibilitÃ© dâ€™avoir **des champs privÃ©s (`#password`)**.  
âŒ **Attention**, sous le capot, cela utilise toujours **le mÃ©canisme de prototype** !

---


## HÃ©ritage grÃ¢ce Ã  la ChaÃ®ne de Prototypes

> **ğŸ“Œ Comment JavaScript cherche une mÃ©thode ou propriÃ©tÃ© dans la chaÃ®ne de prototypes ?**

Exemple :

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  
  speak() {
    console.log(`${this.name} fait un bruit.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} aboie.`);
  }
}

const myDog = new Dog("Rex");

myDog.speak(); // Rex aboie.
console.log(myDog.hasOwnProperty("speak")); // false (il est sur le prototype)
console.log(Object.getPrototypeOf(myDog) === Dog.prototype); // true
console.log(Object.getPrototypeOf(Dog.prototype) === Animal.prototype); // true
console.log(Object.getPrototypeOf(Animal.prototype) === Object.prototype); // true
console.log(Object.getPrototypeOf(Object.prototype)); // null
```



  ```
  myDog
  â”œâ”€â”€ propriÃ©tÃ©s
  â”‚   â”œâ”€â”€ name: String
  â””â”€â”€ *prototype* (Dog.prototype)
      â”œâ”€â”€ propriÃ©tÃ©s
      â”‚   â””â”€â”€ speak(): [Fonction]
      â””â”€â”€ *prototype* (Animal.prototype)
            â”œâ”€â”€ propriÃ©tÃ©s
            â”‚   â””â”€â”€ speak(): [Fonction]
            â””â”€â”€ *prototype* (Object.prototype) 
                    â”œâ”€â”€ propriÃ©tÃ©s
                    â”‚   â””â”€â”€ hasOwnProperty(): [Fonction]
                    â””â”€â”€ *prototype* (null)
  ```


âœ… **Si une mÃ©thode nâ€™est pas trouvÃ©e**, JavaScript **remonte la chaÃ®ne** jusqu'Ã  `Object.prototype`.  
âœ… **Si elle nâ€™existe pas, il retourne `undefined`**.  
âŒ **Attention** : Si une mÃ©thode `speak()` existe dans `Dog.prototype`, celle de `Animal.prototype` est ignorÃ©e.



### HÃ©ritage Prototypal avec `Object.create()`

```js
const mammal = {
  breathe() {
    console.log("Respire...");
  }
};

const cat = Object.create(mammal, {
  breathe: {
    value: function() {
      console.log("Le chat respire doucement...");
    }
  },
  meow: {
    value: function() {
      console.log("Miaou !");
    }
  }
});

cat.breathe();  // Le chat respire doucement...
cat.meow();     // Miaou !
```
âœ… Permet de **crÃ©er un objet sans `class`** avec une **chaÃ®ne dâ€™hÃ©ritage explicite**.  

---

### HÃ©ritage avec `extends`

```js
class Employee {
  constructor(name, salary) {
    this.name = name;
    this.salary = salary;
  }
  
  showInfo() {
    console.log(`${this.name} gagne ${this.salary}â‚¬.`);
  }
}

class Manager extends Employee {
  constructor(name, salary, department) {
    super(name, salary);
    this.department = department;
  }

  showInfo() {
    console.log(`${this.name}, manager du dÃ©partement ${this.department}, gagne ${this.salary}â‚¬.`);
  }
}

const boss = new Manager("Sophie", 80000, "IT");
boss.showInfo(); // Sophie, manager du dÃ©partement IT, gagne 80000â‚¬.
```

âœ… `super()` permet **dâ€™appeler le constructeur parent**.  
âœ… **Plus lisible** que `Object.create()`, recommandÃ© pour **du code moderne**.  

---

# Conclusion

ğŸ”¹ **Comprendre le fonctionnement des objets et prototypes est essentiel pour bien gÃ©rer les modÃ¨les objets.**  
ğŸ”¹ **Les classes en ES6 facilitent la programmation objet**, mais sous le capot, tout repose sur **les prototypes**.  
ğŸ”¹ **Les prototypes permettent un hÃ©ritage puissant**, mais ce mÃ©canisme est diffÃ©rents des schÃ©mas d'hÃ©ritage classiques en gÃ©nie logiciel (java)

